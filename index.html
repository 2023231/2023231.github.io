<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì˜¤ëª©</title>
    <!-- Tailwind CSS CDNì„ í¬í•¨í•˜ì—¬ ìŠ¤íƒ€ì¼ë§ì— ì‚¬ìš©í•©ë‹ˆë‹¤. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #1a202c;
            padding: 1rem;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 90%;
            width: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            background-color: #a07c5a;
            touch-action: none;
            cursor: pointer;
        }
        .button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        #message-box {
            min-height: 2.5rem;
        }
        .message-content {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .timer-display {
            font-size: 1.25rem;
            font-weight: bold;
            color: #4a5568;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

<div class="container">
    <h1 class="text-3xl font-bold text-gray-800 mb-4">ìµœê°• AI ì˜¤ëª© ê²Œì„</h1>
    <p class="text-center text-gray-600 mb-6">
        ë¨¼ì € 5ê°œì˜ ëŒì„ ì—°ê²°í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤! (í‘ëŒì€ 3-3, 4-4, 6ëª© ê¸ˆìˆ˜)
    </p>

    <div id="game-info" class="flex justify-between items-center w-full max-w-[500px] mb-4">
        <div class="text-center">
            <p class="font-bold">ë‹¹ì‹ </p>
            <p id="player-time" class="timer-display">05:00</p>
        </div>
        <div class="text-center">
            <p class="font-bold">AI</p>
            <p id="ai-time" class="timer-display">05:00</p>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="message-box" class="mt-4 text-lg font-semibold text-center text-gray-700">
        <span class="message-content"></span>
    </div>

    <div id="menu-screen" class="flex flex-col items-center mt-6 w-full">
        <p class="text-lg font-semibold mb-4">ë‹¹ì‹ ì˜ ëŒ ìƒ‰ê¹”ì„ ì„ íƒí•˜ì„¸ìš”.</p>
        <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
            <button id="blackButton" class="button bg-gray-800 hover:bg-gray-900 text-white font-bold py-2 px-6 rounded-full">
                <svg class="h-5 w-5 inline-block mr-2" fill="white" viewBox="0 0 20 20"><circle cx="10" cy="10" r="10"/></svg>
                ê²€ì€ ëŒ
            </button>
            <button id="whiteButton" class="button bg-white hover:bg-gray-100 text-gray-800 font-bold py-2 px-6 rounded-full border border-gray-300">
                <svg class="h-5 w-5 inline-block mr-2" fill="black" viewBox="0 0 20 20"><circle cx="10" cy="10" r="10"/></svg>
                í° ëŒ
            </button>
        </div>
        <button id="startButton" class="button mt-6 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full">
            ê²Œì„ ì‹œì‘
        </button>
    </div>

</div>

<script>
    // --- UI ìš”ì†Œ ---
    // HTMLì—ì„œ í•„ìš”í•œ ìš”ì†Œë“¤ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const blackButton = document.getElementById('blackButton');
    const whiteButton = document.getElementById('whiteButton');
    const startButton = document.getElementById('startButton');
    const menuScreen = document.getElementById('menu-screen');
    const messageBox = document.getElementById('message-box');
    const playerTimeDisplay = document.getElementById('player-time');
    const aiTimeDisplay = document.getElementById('ai-time');

    // --- ê²Œì„ ìƒìˆ˜ ---
    // ê²Œì„íŒì˜ í¬ê¸°, ëŒì˜ í¬ê¸° ë“±ì„ ì •ì˜í•©ë‹ˆë‹¤.
    const BOARD_SIZE = 19; // ì˜¤ëª©íŒ ê²©ì í¬ê¸°
    const CELL_SIZE = 25; // í•œ ì¹¸ì˜ ë„ˆë¹„/ë†’ì´
    const PADDING = 25; // ì˜¤ëª©íŒ ì£¼ë³€ ì—¬ë°±
    const WIN_COUNT = 5; // ìŠ¹ë¦¬í•˜ëŠ” ë° í•„ìš”í•œ ëŒì˜ ìˆ˜
    const AI_SEARCH_DEPTH = 4; // AIì˜ íƒìƒ‰ ê¹Šì´. ìˆ«ìê°€ ë†’ì„ìˆ˜ë¡ AIê°€ ë” ê°•ë ¥í•´ì§‘ë‹ˆë‹¤.
    const INITIAL_TIME_LIMIT = 5 * 60; // 5ë¶„ in seconds

    // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
    let board = []; // ê²Œì„íŒì˜ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” 2ì°¨ì› ë°°ì—´
    let playerColor = 'black'; // ì‚¬ìš©ìê°€ ì„ íƒí•œ ëŒ ìƒ‰ê¹”
    let aiColor = 'white'; // AIì˜ ëŒ ìƒ‰ê¹”
    let currentPlayer = null; // í˜„ì¬ í„´ì„ ê°€ì§„ í”Œë ˆì´ì–´
    let isGameOver = false; // ê²Œì„ ì¢…ë£Œ ì—¬ë¶€
    let playerTime = INITIAL_TIME_LIMIT; // ì‚¬ìš©ì ë‚¨ì€ ì‹œê°„
    let aiTime = INITIAL_TIME_LIMIT; // AI ë‚¨ì€ ì‹œê°„
    let timerInterval = null; // íƒ€ì´ë¨¸ë¥¼ ìœ„í•œ ë³€ìˆ˜

    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    const canvasSize = (BOARD_SIZE - 1) * CELL_SIZE + 2 * PADDING;
    canvas.width = canvasSize;
    canvas.height = canvasSize;

    // --- UI ë¡œì§ ---
    // ì„ íƒëœ ëŒ ìƒ‰ê¹”ì— ë”°ë¼ ë²„íŠ¼ ìŠ¤íƒ€ì¼ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    function updateSelectedColor() {
        if (playerColor === 'black') {
            blackButton.classList.add('ring-4', 'ring-blue-500', 'ring-opacity-50');
            whiteButton.classList.remove('ring-4', 'ring-blue-500', 'ring-opacity-50');
        } else {
            whiteButton.classList.add('ring-4', 'ring-blue-500', 'ring-opacity-50');
            blackButton.classList.remove('ring-4', 'ring-blue-500', 'ring-opacity-50');
        }
    }

    // --- ê²Œì„ ê´€ë¦¬ ---
    // ê²Œì„ì„ ì´ˆê¸° ìƒíƒœë¡œ ì„¤ì •í•˜ê³  ì‹œì‘í•©ë‹ˆë‹¤.
    function initGame() {
        menuScreen.style.display = 'none';
        
        // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
        board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
        isGameOver = false;
        playerTime = INITIAL_TIME_LIMIT;
        aiTime = INITIAL_TIME_LIMIT;
        
        // ë°±ëŒ(í°ìƒ‰)ì´ ë¨¼ì € ì‹œì‘í•©ë‹ˆë‹¤.
        currentPlayer = 'white';
        
        drawBoard();
        updateMessage();
        updateTimers();

        // ì‚¬ìš©ìê°€ í°ëŒì„ ì„ íƒí–ˆìœ¼ë©´ ì‚¬ìš©ì ë¨¼ì €, ì•„ë‹ˆë©´ AI ë¨¼ì € ì‹œì‘
        if (playerColor === 'white') {
            startTimer('player');
            canvas.addEventListener('click', handleMove);
        } else {
            startTimer('ai');
            setTimeout(aiMove, 500);
        }
    }

    // --- íƒ€ì´ë¨¸ ë¡œì§ ---
    // í˜„ì¬ í”Œë ˆì´ì–´ì˜ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
    function startTimer(color) {
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            if (color === 'player') {
                playerTime--;
                if (playerTime <= 0) {
                    endGame('ai'); // ì‹œê°„ ì´ˆê³¼ ì‹œ AI ìŠ¹ë¦¬
                }
            } else {
                aiTime--;
                if (aiTime <= 0) {
                    endGame('player'); // ì‹œê°„ ì´ˆê³¼ ì‹œ ì‚¬ìš©ì ìŠ¹ë¦¬
                }
            }
            updateTimers();
        }, 1000);
    }
    
    // íƒ€ì´ë¨¸ë¥¼ ë©ˆì¶¥ë‹ˆë‹¤.
    function stopTimer() {
        clearInterval(timerInterval);
    }

    // í™”ë©´ì— ë‚¨ì€ ì‹œê°„ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    function updateTimers() {
        const formatTime = (seconds) => {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        };
        playerTimeDisplay.textContent = formatTime(playerTime);
        aiTimeDisplay.textContent = formatTime(aiTime);
    }

    // --- ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---
    // ì˜¤ëª©íŒì„ ê·¸ë¦½ë‹ˆë‹¤.
    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#a07c5a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 1;
        // ê²©ì ì„  ê·¸ë¦¬ê¸°
        for (let i = 0; i < BOARD_SIZE; i++) {
            ctx.beginPath();
            ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
            ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (BOARD_SIZE - 1) * CELL_SIZE);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
            ctx.lineTo(PADDING + (BOARD_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
            ctx.stroke();
        }

        // ëŒ ê·¸ë¦¬ê¸°
        for (let row = 0; row < BOARD_SIZE; row++) {
            for (let col = 0; col < BOARD_SIZE; col++) {
                if (board[row][col] !== null) {
                    drawStone(row, col, board[row][col]);
                }
            }
        }
    }

    // ì§€ì •ëœ ìœ„ì¹˜ì— ëŒì„ ê·¸ë¦½ë‹ˆë‹¤.
    function drawStone(row, col, color) {
        const x = PADDING + col * CELL_SIZE;
        const y = PADDING + row * CELL_SIZE;

        ctx.beginPath();
        ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(x - CELL_SIZE / 6, y - CELL_SIZE / 6, CELL_SIZE / 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }

    // --- ê²Œì„ ë¡œì§ ---
    // ì‚¬ìš©ìì˜ í´ë¦­ì„ ì²˜ë¦¬í•˜ì—¬ ëŒì„ ë†“ìŠµë‹ˆë‹¤.
    function handleMove(event) {
        if (isGameOver || currentPlayer !== playerColor) return;

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const col = Math.round((x - PADDING) / CELL_SIZE);
        const row = Math.round((y - PADDING) / CELL_SIZE);

        if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE && board[row][col] === null) {
            // í‘ëŒì¼ ê²½ìš° ê¸ˆìˆ˜ ì²´í¬
            if (playerColor === 'black' && checkForbiddenMove(row, col)) {
                showMessage("ê¸ˆìˆ˜(3-3, 4-4 ë˜ëŠ” 6ëª©)ëŠ” ë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }
            placeStone(row, col, playerColor);
        } else if (board[row][col] !== null) {
            showMessage("ì´ë¯¸ ëŒì´ ìˆëŠ” ê³³ì—ëŠ” ë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
    }

    // ì§€ì •ëœ ìœ„ì¹˜ì— ëŒì„ ë†“ê³ , ìŠ¹ë¦¬ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
    function placeStone(row, col, color) {
        board[row][col] = color;
        drawBoard();
        
        if (checkWin(row, col, color)) {
            endGame(color);
        } else if (isBoardFull()) {
            endGame('draw');
        } else {
            switchTurn();
        }
    }

    // í„´ì„ ì „í™˜í•˜ê³  ë‹¤ìŒ í”Œë ˆì´ì–´ì—ê²Œ ì•Œë¦½ë‹ˆë‹¤.
    function switchTurn() {
        stopTimer();
        currentPlayer = (currentPlayer === playerColor) ? aiColor : playerColor;
        updateMessage();
        if (currentPlayer === aiColor) {
            startTimer('ai');
            setTimeout(aiMove, 500);
        } else {
            startTimer('player');
        }
    }

    // ìŠ¹ë¦¬ ì¡°ê±´ì„ í™•ì¸í•©ë‹ˆë‹¤.
    function checkWin(row, col, color) {
        const directions = [
            [0, 1], [1, 0], [1, 1], [1, -1]
        ];
        
        for (const [dr, dc] of directions) {
            let count = 1;
            // ì•ë’¤ë¡œ ëŒì˜ ìˆ˜ë¥¼ ì…‰ë‹ˆë‹¤.
            for (let i = 1; i <= WIN_COUNT; i++) {
                const r = row + i * dr;
                const c = col + i * dc;
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === color) {
                    count++;
                } else {
                    break;
                }
            }
            for (let i = 1; i <= WIN_COUNT; i++) {
                const r = row - i * dr;
                const c = col - i * dc;
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === color) {
                    count++;
                } else {
                    break;
                }
            }
            if (count === WIN_COUNT) return true;
        }
        return false;
    }
    
    // í‘ëŒì˜ ê¸ˆìˆ˜(3-3, 4-4, 6ëª©)ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
    function checkForbiddenMove(row, col) {
        // ì„ì‹œ ë³´ë“œë¥¼ ë§Œë“¤ì–´ ê¸ˆìˆ˜ ì—¬ë¶€ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.
        const tempBoard = JSON.parse(JSON.stringify(board));
        tempBoard[row][col] = 'black';

        let threeCount = 0;
        let fourCount = 0;

        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        
        // 6ëª© (6ê°œ ì´ìƒì˜ ëŒ) ì²´í¬
        for (const [dr, dc] of directions) {
            let count = 1;
            let r = row, c = col;
            while (r + dr >= 0 && r + dr < BOARD_SIZE && c + dc >= 0 && c + dc < BOARD_SIZE && tempBoard[r + dr][c + dc] === 'black') {
                count++;
                r += dr;
            }
            r = row, c = col;
            while (r - dr >= 0 && r - dr < BOARD_SIZE && c - dc >= 0 && c - dc < BOARD_SIZE && tempBoard[r - dr][c - dc] === 'black') {
                count++;
                r -= dr;
            }
            if (count > WIN_COUNT) return true;
        }

        // 3-3, 4-4 ì²´í¬
        for (const [dr, dc] of directions) {
            let lineLength = 1;
            let openEnds = 0;
            
            // ì• ë°©í–¥ ì²´í¬
            let r = row, c = col;
            if (r + dr >= 0 && r + dr < BOARD_SIZE && c + dc >= 0 && c + dc < BOARD_SIZE && tempBoard[r + dr][c + dc] === null) {
                openEnds++;
            }
            while (r - dr >= 0 && r - dr < BOARD_SIZE && c - dc >= 0 && c - dc < BOARD_SIZE && tempBoard[r - dr][c - dc] === 'black') {
                lineLength++;
                r -= dr;
            }
            if (r - dr >= 0 && r - dr < BOARD_SIZE && c - dc >= 0 && c - dc < BOARD_SIZE && tempBoard[r - dr][c - dc] === null) {
                openEnds++;
            }
            
            // ë’· ë°©í–¥ ì²´í¬
            r = row, c = col;
            while (r + dr >= 0 && r + dr < BOARD_SIZE && c + dc >= 0 && c + dc < BOARD_SIZE && tempBoard[r + dr][c + dc] === 'black') {
                lineLength++;
                r += dr;
            }
            if (r + dr >= 0 && r + dr < BOARD_SIZE && c + dc >= 0 && c + dc < BOARD_SIZE && tempBoard[r + dr][c + dc] === null) {
                openEnds++;
            }
            
            if (lineLength === 3 && openEnds === 2) threeCount++;
            if (lineLength === 4 && openEnds === 2) fourCount++;
        }
        return threeCount >= 2 || fourCount >= 2;
    }

    // ê²Œì„íŒì´ ê°€ë“ ì°¼ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    function isBoardFull() {
        for (let row = 0; row < BOARD_SIZE; row++) {
            for (let col = 0; col < BOARD_SIZE; col++) {
                if (board[row][col] === null) return false;
            }
        }
        return true;
    }

    // ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ê²°ê³¼ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    function endGame(winner) {
        isGameOver = true;
        stopTimer();
        let message = '';
        if (winner === 'draw') {
            message = 'ë¬´ìŠ¹ë¶€ì…ë‹ˆë‹¤!';
        } else {
            const winnerName = (winner === playerColor) ? 'ë‹¹ì‹ ' : 'AI';
            message = `${winnerName}ì˜ ìŠ¹ë¦¬ì…ë‹ˆë‹¤! ğŸ‰`;
        }
        showMessage(message);
        setTimeout(() => {
            menuScreen.style.display = 'flex'; // 3ì´ˆ í›„ ë©”ë‰´ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°
        }, 3000);
    }

    // --- AI ë¡œì§ (Minimax with Alpha-Beta Pruning) ---
    // AIê°€ ìµœì ì˜ ìˆ˜ë¥¼ ì°¾ì•„ì„œ ë‘¡ë‹ˆë‹¤.
    function aiMove() {
        if (isGameOver) return;
        showMessage("AIê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤...");
        
        const bestMove = findBestMove(board, AI_SEARCH_DEPTH, aiColor);
        if (bestMove) {
            placeStone(bestMove.row, bestMove.col, aiColor);
        } else {
            endGame('draw');
        }
    }

    // AIì˜ ìµœì ì˜ ìˆ˜ë¥¼ ì°¾ëŠ” Minimax ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œì‘ì 
    function findBestMove(board, depth, color) {
        let bestScore = -Infinity;
        let bestMove = null;
        let alpha = -Infinity;
        let beta = Infinity;

        const emptyCells = getPossibleMoves(board);
        if (emptyCells.length === 0) return null;

        for (const move of emptyCells) {
            board[move.row][move.col] = color;
            const score = minimax(board, depth - 1, false, alpha, beta);
            board[move.row][move.col] = null;
            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
            alpha = Math.max(alpha, score);
        }
        return bestMove;
    }

    // ì¬ê·€ì ìœ¼ë¡œ ìµœì ì˜ ìˆ˜ë¥¼ ì°¾ëŠ” Minimax í•¨ìˆ˜
    function minimax(board, depth, isMaximizingPlayer, alpha, beta) {
        const score = evaluateBoard(board);
        // ê²Œì„ ì¢…ë£Œ, ê¹Šì´ í•œê³„ ë„ë‹¬, ë˜ëŠ” ìŠ¹íŒ¨ê°€ ê²°ì •ë˜ë©´ í˜„ì¬ ì ìˆ˜ ë°˜í™˜
        if (depth === 0 || isGameOver || Math.abs(score) > 100000) {
            return score;
        }

        const color = isMaximizingPlayer ? aiColor : playerColor;
        const possibleMoves = getPossibleMoves(board);

        if (isMaximizingPlayer) {
            let maxEval = -Infinity;
            for (const move of possibleMoves) {
                board[move.row][move.col] = color;
                const eval = minimax(board, depth - 1, false, alpha, beta);
                board[move.row][move.col] = null;
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) break; // Alpha-Beta Pruning
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const move of possibleMoves) {
                board[move.row][move.col] = color;
                const eval = minimax(board, depth - 1, true, alpha, beta);
                board[move.row][move.col] = null;
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) break; // Alpha-Beta Pruning
            }
            return minEval;
        }
    }
    
    // í˜„ì¬ ë†“ì¸ ëŒ ì£¼ë³€ì˜ ìœ íš¨í•œ ë¹ˆ ì¹¸ì„ ì°¾ìŠµë‹ˆë‹¤.
    function getPossibleMoves(board) {
        const moves = [];
        const checked = new Set();
        const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];

        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] !== null) {
                    for (const [dr, dc] of directions) {
                        for (let i = 1; i <= 2; i++) {
                            const newR = r + i * dr;
                            const newC = c + i * dc;
                            if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && board[newR][newC] === null) {
                                const key = `${newR}-${newC}`;
                                if (!checked.has(key)) {
                                    moves.push({ row: newR, col: newC });
                                    checked.add(key);
                                }
                            }
                        }
                    }
                }
            }
        }
        return moves.length > 0 ? moves : getAllEmptyCells(board);
    }
    
    // ëª¨ë“  ë¹ˆ ì¹¸ì„ ë°°ì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
    function getAllEmptyCells(board) {
        const emptyCells = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] === null) {
                    emptyCells.push({ row: r, col: c });
                }
            }
        }
        return emptyCells;
    }

    // í˜„ì¬ ê²Œì„íŒì˜ ì ìˆ˜ë¥¼ í‰ê°€í•©ë‹ˆë‹¤.
    function evaluateBoard(board) {
        let score = 0;
        score += evaluatePlayer(board, aiColor) - evaluatePlayer(board, playerColor);
        return score;
    }

    // íŠ¹ì • í”Œë ˆì´ì–´ì˜ ê²Œì„íŒ ì ìˆ˜ë¥¼ í‰ê°€í•˜ëŠ” í•¨ìˆ˜
    function evaluatePlayer(board, color) {
        let score = 0;
        const opponent = (color === aiColor) ? playerColor : aiColor;

        const patterns = {
            '5': 1000000,
            'open_4': 100000,
            'blocked_4': 1000,
            'open_3': 1000,
            'blocked_3': 100,
            'open_2': 100,
            'blocked_2': 10
        };

        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

        // ë¹ˆ ì¹¸ì„ ê¸°ì¤€ìœ¼ë¡œ ì£¼ë³€ íŒ¨í„´ì„ í‰ê°€í•˜ì—¬ ì ìˆ˜ë¥¼ ë§¤ê¹ë‹ˆë‹¤.
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] === null) {
                    for (const [dr, dc] of directions) {
                        let myCount = 0;
                        let opponentCount = 0;
                        
                        for (let i = -4; i <= 4; i++) {
                            const newR = r + i * dr;
                            const newC = c + i * dc;
                            if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE) {
                                if (board[newR][newC] === color) {
                                    myCount++;
                                } else if (board[newR][newC] === opponent) {
                                    opponentCount++;
                                }
                            }
                        }

                        if (opponentCount === 0) {
                            if (myCount === 4) score += patterns['open_4'];
                            else if (myCount === 3) score += patterns['open_3'];
                            else if (myCount === 2) score += patterns['open_2'];
                        } else if (myCount === 0) {
                            if (opponentCount === 4) score -= patterns['open_4'];
                            else if (opponentCount === 3) score -= patterns['open_3'];
                            else if (opponentCount === 2) score -= patterns['open_2'];
                        }
                    }
                }
            }
        }
        
        // 5ëª© ìŠ¹ë¦¬ íŒ¨í„´ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        for(let r = 0; r < BOARD_SIZE; r++) {
            for(let c = 0; c < BOARD_SIZE; c++) {
                if(board[r][c] === color && checkWin(r, c, color)) return patterns['5'];
                if(board[r][c] === opponent && checkWin(r, c, opponent)) return -patterns['5'];
            }
        }

        return score;
    }

    // --- ë©”ì‹œì§€ ë° UI ì—…ë°ì´íŠ¸ ---
    // ë©”ì‹œì§€ ë°•ìŠ¤ì— í…ìŠ¤íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    function showMessage(text) {
        messageBox.innerHTML = `<span class="message-content">${text}</span>`;
    }

    // í˜„ì¬ í„´ì— ë§ëŠ” ë©”ì‹œì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    function updateMessage() {
        const currentPlayerName = (currentPlayer === playerColor) ? 'ë‹¹ì‹ ' : 'AI';
        const stoneColor = (currentPlayer === 'black') ? 'ê²€ì€ ëŒ' : 'í° ëŒ';
        showMessage(`${currentPlayerName}ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (${stoneColor}).`);
    }

    // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
    // í‘ëŒ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
    blackButton.addEventListener('click', () => {
        playerColor = 'black';
        aiColor = 'white';
        updateSelectedColor();
    });
    
    // í°ëŒ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
    whiteButton.addEventListener('click', () => {
        playerColor = 'white';
        aiColor = 'black';
        updateSelectedColor();
    });

    // ê²Œì„ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
    startButton.addEventListener('click', initGame);
    
    // ì´ˆê¸° ì„¤ì •
    updateSelectedColor();
    showMessage('ë‹¹ì‹ ì˜ ëŒ ìƒ‰ê¹”ì„ ì„ íƒí•˜ê³  ê²Œì„ ì‹œì‘ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.');
    
</script>

</body>
</html>
